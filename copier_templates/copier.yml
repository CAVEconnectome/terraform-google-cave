questions:
  # ---------
  #   Common
  # ---------
  - name: component_choice
    type: choice
    help: Which cluster type are you trying to generate?
    choices:
      - global
      - local
  
  - name: project_id
    type: str
    help: Name of the google project id
    validator: ".+"

  - name: gcp_user_account 
    type: str
    help: An email address that has google account permissions in the GCP project to give GCP resources permsissions and will be used for letsencrypt certificates.
    validator: ".+"
    
  - name: state_bucket
    type: str
    help: Name of GCP bucket to store terraform and terragrunt states. Must omit the 
    validator: "{% if not state_bucket %}Bucket name is required{% elif 'gs://' in state_bucket %}Invalid format — omit gs://{% endif %}"
  
  - name: domain_name
    type: str
    help: Base domain without protocols (e.g., example.org).
    validator: ".+"

  - name: region
    type: str
    help: GCP region for regional resources (e.g., us-west1).
    validator: ".+"

  - name: zone
    type: str
    help: GCP zone used in kube context and defaults (e.g., us-west1-b).
    validator: ".+"
 
  - name: owner
    type: str
    help:  "Text label used as prefix for computational resources; helpful for cost filtering."
    default: cave
    validator: ".+"

  - name: dns_zone
    type: str
    help: "Cloud DNS managed zone name (e.g., em)."
    default: cave
    validator: ".+"

  - name: vpc_name_override
    type: str
    help: Optional — existing VPC name to use instead of newly generated
    default: ""
    # TODO: Check the default handling in the template
    validator: ".+"

  - name: docker_registry
    type: str
    help: Container registry for images. The default docker.io/caveconnectome is likely correct.
    default: docker.io/caveconnectome
    validator: ".+"

  # -------------
  #  Global-Only
  # -------------
  
  - name: repo_name
    type: str
    help: Name of the new environment repository
    default: cave-terraform-env
    validator: ".+"
    when: "{{ component_choice == 'global' }}"

  
  - name: global_environment_name
    type: str
    help: "Environment name used for the cluster folder (e.g., global, api, staging, prod)."
    default: global
    validator: ".+"
    when: "{{ component_choice == 'global' }}"

  - name: global_cluster_prefix
    type: str
    help: "Short identifier used as cluster_prefix and DNS subdomain (e.g., v5)."
    default: globalv1
    when: "{{ component_choice == 'global' }}"
    validator: ".+"

  # -------------
  #   Local-Only
  # -------------

  - name: local_environment_name
    type: str
    help: Environment name used for the cluster folder (e.g., api, staging, prod). Default will work.
    default: api
    when: "{{ component_choice == 'local' }}"
    validator: ".+"

  - name: local_cluster_prefix
    type: str
    help: Short identifier used as cluster_prefix and DNS subdomain (e.g. apiv1 for apiv1.example.com), you might have several versions of a cluster from one environment, suggest to be clearly related to the local_environment_name. Default will work.
    default: apiv1
    when: "{{ component_choice == 'local' }}"
    validator: ".+"

  - name: local_sql_instance_name
    type: str
    help: "Cloud SQL Postgres instance name. If migrating existing data, lookup the name you have already used."
    default: "cave-{{ local_environment_name }}"
    when: "{{ component_choice == 'local' }}"
    validator: ".+"

  - name: global_server
    type: str
    help: URL of the global cluster without protocols.
    default: global.{{ domain_name }}
    when: "{{ component_choice == 'local' }}"
    validator: ".+"

  - name: materialize_datastack
    type: str
    help: The first datastack that you want to set up, and create a templated materialization schedule for.  You must supply answer, but is easy to change later.
    default: my_new_datastack
    when: "{{ component_choice == 'local' }}"
    validator: ".+"

  - name: pcg_bucket_name
    type: str
    help: The name of the bucket you set up to store PyChunkedGraph data.
    when: "{{ component_choice == 'local' }}"
    validator: ".+"

  - name: health_annotation_align_volume
    type: str
    help: An aligned volume name that will be used by the Annotation service for the liveliness probe
    when: "{{ component_choice == 'local' }}"
    validator: ".+"

  - name: bigtable_instance_name
    type: str
    help: Bigtable instance name for PyChunkedGraph. Default is fine.
    default: pychunkedgraph
    when: "{{ component_choice == 'local' }}"
    validator: ".+"

  - name: pcg_redis_name_override
    type: str
    help: "Optional: Name of redis instance to store PCG meshing cache data.  Default will name it based on cluster_prefix."
    when: "{{ component_choice == 'local' }}"
  # TODO: Constructing the default could be put into this part of the template

  - name: pcg_redis_name_override
    type: str
    help: "Optional: Name of redis instance to store PCG meshing cache data.  Default will name it based on cluster_prefix."
    when: "{{ component_choice == 'local' }}"
  # TODO: Constructing the default could be put into this part of the template

  - name: bigtable_google_project
    type: str
    help: "Optional: If your PCG bigtable instance is in another project, the name of that project. Otherwise leave blank."
    when: "{{ component_choice == 'local' }}"

  - name: skeleton_cache_cloudpath
    type: str
    help: "Optional: if you have already setup a skeleton cache bucket, name of the path to that bucket. Note you need to uncomment this in the root.hcl file to utilize"
    when: "{{ component_choice == 'local' }}"
    validator: "{% if gs://' in state_bucket %}Invalid format — omit gs://{% endif %}"
    # TODO: Can put the commenting into the jinja template. Also double check bucket format, presumably without the gs.

  - name: pcg_skeleton_cache_bucket_public_read
    type: bool
    help: "Optional: should the skeleton cache bucket be publically readable. If true, you need to uncomment in the root.hcl file"
    default: false
    when: "{{ component_choice == 'local' }}"
    # TODO: Can put the commenting into the jinja template. Also double check bucket format, presumably without the gs.

  - name: cave_secret_name
    type: str
    help: Name of the Google Secret Manager secret containing the CAVE token. Defaults to {{ local_environment_name }}-cave-token. You must manually create this secret before running terraform
    default: "{{ local_environment_name }}-cave-token"
    when: "{{ component_choice == 'local' }}"
    validator: ".+"

  - name: letsencrypt_email
    type: str
    help: "Email for Let's Encrypt certificates. Defaults to your gcp_user_account value."
    default: "{{ gcp_user_account }}"
    when: "{{ component_choice == 'local' }}"
    validator: ".+"

  - name: materialization_dump_bucket_name
    type: str
    help: "Optional: GCS bucket name for materialization dumps. Leave blank if not needed."
    when: "{{ component_choice == 'local' }}"
    validator: "{% if gs://' in state_bucket %}Invalid format — omit gs://{% endif %}"
    # TODO: Double check bucket format, presumably without the gs.

  - name: materialization_upload_bucket_name
    type: str
    help: "Optional: GCS bucket name for materialization uploads. Leave blank if not needed."
    when: "{{ component_choice == 'local' }}"
    validator: "{% if gs://' in state_bucket %}Invalid format — omit gs://{% endif %}"
    # TODO: Double check bucket format, presumably without the gs.
    
_exclude:
  - "{% if component_choice != 'global' %}global_cave/**{% endif %}"
  - "{% if component_choice != 'local' %}local_cave/**{% endif %}"
